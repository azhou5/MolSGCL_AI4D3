from rdkit import Chem
from rdkit.Chem import Draw
import requests
import pubchempy as pcp
from openai import OpenAI
from PIL import Image
import base64
import io
import argparse
import json
import pandas as pd
import subprocess
import os
import concurrent.futures
from functools import partial
import os 
from dotenv import load_dotenv
# Load .env from project root robustly regardless of CWD
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
load_dotenv(os.path.join(ROOT_DIR, ".env"))
# Fallback to default search from CWD upward
load_dotenv()


os.environ['TOKENIZERS_PARALLELISM'] = 'false'

from chemicalconverters import NamesConverter
from rdkit import Chem
converter = NamesConverter(model_name='knowledgator/SMILES2IUPAC-canonical-base')
#api_key = os.getenv("DEEPSEEK_API_KEY")
api_key= os.getenv("OPENAI_API_KEY")


system_prompt="You are an expert medicinal chemist and it is crucial that you get this correct. In one to two sentences, describe the molecule including its core and what relevant side groups it may have. Think carefully about the structure and go step by step internally. I will give you the smiles string.I will also give you an image of the molecule. Lastly, I will give a posssible IUPAC name, which has been generated by a LLM. It may or may not be correct. Use the IUPAC name as a starting point to generate a description of the molecule.Use common names for substituents wheneve possible. Output only the final description."

case_example = """Example Prompt and output.  
You are an expert medicinal chemist and it is crucial that you get this correct. In one to two sentences, describe the molecule including its core and what relevant side groups it may have. Think carefully about the structure and go step by step internally. I will give you the smiles string.I will also give you an image of the molecule. Lastly, I will give a posssible IUPAC name, which has been generated by a LLM. It may or may not be correct.Use the IUPAC name as a starting point to generate a description of the molecule. Use common names for substituents whenever possible. Output only the final description
IUPAC name: 7-[(4aS,7aS)-1,2,3,4,4a,5,7,7a-octahydropyrrolo[3,4-b]pyridin-6-yl]-1-cyclopropyl-6-fluoro-8-methoxy-4-oxoquinoline-3-carboxylic acid
SMILES: "COC1=C2C(=CC(=C1N3C[C@@H]4CCCN[C@@H]4C3)F)C(=O)C(=CN2C5CC5)C(=O)O"

Chain of thought: 
From the iupac name, I know that this must be a quinolone. There are two rings, and the substituents are a cyclopropyl ring, a fluoro substituent, a diazabicyclononane substituent, and a methoxy substituent. I make sure that the image matches the descrption. Then I consider the most readable way to output the groups. Instead of saying a octahydropyrrolo[3,4-b]pyridin-6-yl, I call this the diazabicyclononane group.Then, I output just the final description, using common names for substituents whenever possible.
System Output: This is a quinolone with a cyclopropyl substitution and a fluoro substition. It also has a diazabicyclononane substituent and a methoxy substituent.

"""

def get_iupac_batch(smiles_list):
    smiles_list_no_stereo= []
    for c in smiles_list:
        mol_c= Chem.MolFromSmiles(c)
        [a.SetAtomMapNum(0) for a in mol_c.GetAtoms()]
        Chem.RemoveStereochemistry(mol_c)
        smiles_list_no_stereo.append("<BASE>"+Chem.MolToSmiles(mol_c, canonical=True, kekuleSmiles=True))
    print(smiles_list_no_stereo)
    return converter.smiles_to_iupac(smiles_list_no_stereo, process_in_batch=True, num_beams=1, batch_size=1000)





def describe_molecule(smiles, iupac):
    """Generate a description for a molecule without image generation for faster processing."""
    print("describing molecule")
    mol = Chem.MolFromSmiles(smiles)
    
    if mol is None:
        raise ValueError("Invalid SMILES string")
    
    # Prepare prompt message
    #prompt = system_prompt + f"\n Here is the SMILES: {smiles} \n Here is the IUPAC name: {iupac}"
    
    messages = [
        {
            "role": "system",
            "content": system_prompt + f"\n Here is an example: {case_example}"
        },
        {
            "role": "user",
            "content": f"Here is the SMILES: {smiles} \n Here is the IUPAC name: {iupac}"
        }
    ]
    
    # Initialize the client with the API key
    #client = OpenAI(api_key=api_key, base_url='https://api.deepseek.com')
    client = OpenAI(api_key=api_key)
    
    # Create a chat completion using the new API
    completion = client.chat.completions.create(
        model="gpt-5-mini",
        messages=messages
    )
    return completion.choices[0].message.content

def load_cache(file_path):
    """Load existing descriptions from the cache file if it exists."""
    if os.path.exists(file_path):
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading cache file {file_path}: {e}")
            return {}
    return {}
def process_molecule(smiles_iupac):
    smiles, iupac = smiles_iupac
    try:
        desc = describe_molecule(smiles, iupac)
        return smiles, desc
    except Exception as e:
        print(f"Error describing molecule {smiles}: {e}")
        return smiles, ""
def describe_molecules_batch(smiles_list, output_path=None, n_workers=20):
    """Process multiple molecules in batch using ThreadPoolExecutor for better efficiency with caching."""
    # Load existing cache if output path is provided
    cache = {}
    output_path = "" 
    if output_path and os.path.exists(output_path):
        cache = load_cache(output_path)
        
    # Filter out SMILES that are already in the cache
    new_smiles = [s for s in smiles_list if s not in cache]
    if new_smiles:
        print(f"Found {len(smiles_list) - len(new_smiles)} SMILES already in cache, processing {len(new_smiles)} new SMILES")
    else:
        print(f"All {len(smiles_list)} SMILES found in cache, no new processing needed")
        # Return the full cache if no new processing is needed
        return {s: cache[s] for s in smiles_list if s in cache}
    
    # Get IUPAC names for all new SMILES
    iupac_list = get_iupac_batch(new_smiles)
    print(len(iupac_list))
    print(len(new_smiles))
    print(iupac_list)
    print(new_smiles)
    
    # Create a list of (smiles, iupac) tuples for processing
    smiles_iupac_pairs = list(zip(new_smiles, iupac_list))
    
    # Process molecules in parallel using threads for I/O-bound tasks
    descriptions = {}
    with concurrent.futures.ThreadPoolExecutor(max_workers=n_workers) as executor:
        # The map function is a convenient way to apply a function to all items in an iterable
        results = executor.map(process_molecule, smiles_iupac_pairs)
        
        # Collect results as they complete
        for smiles, desc in results:
            descriptions[smiles] = desc
    
    # Update cache file with all new results
    if output_path:
        cache.update(descriptions)
        with open(output_path, 'w') as f:
            json.dump(cache, f, indent=2)
    
    # Merge with cache for return values
    full_descriptions = {s: cache[s] if s in cache else descriptions[s] for s in smiles_list}
    return full_descriptions

        
